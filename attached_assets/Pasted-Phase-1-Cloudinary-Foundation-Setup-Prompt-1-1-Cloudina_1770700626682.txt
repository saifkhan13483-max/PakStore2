Phase 1: Cloudinary Foundation Setup
Prompt 1.1 - Cloudinary Configuration File

I want to add Cloudinary to my client-side Firebase app for media storage.

Create a new file: `src/config/cloudinary.js`

This file should:
1. Export Cloudinary configuration for client-side uploads
2. Use environment variables for cloud name and upload preset
3. NOT include any secret keys or API secrets (client-side only)
4. Include the upload endpoint URL for direct uploads

Tell me which npm packages to install for client-side Cloudinary integration.
Do not modify any existing Firebase configuration files.
Prompt 1.2 - Upload Preset Configuration Guide

Explain how to create unsigned upload presets in Cloudinary Console for secure client-side uploads.

Provide step-by-step instructions for:
1. Creating an unsigned upload preset
2. Configuring allowed file types (images, videos, documents)
3. Setting file size limits (2MB for images, 10MB for videos)
4. Setting up folder organization (users/{user-id}/)
5. Enabling auto-optimization and format conversion
6. Security restrictions to prevent abuse

Include which settings are critical for security in a client-side setup.
Don't write code yet - just provide Cloudinary Console configuration steps.
Prompt 1.3 - Environment Variables Setup

Based on the Cloudinary config we're creating, tell me:
1. Which environment variables I need for client-side Cloudinary integration
2. How to get the cloud name from Cloudinary Console
3. How to get the upload preset name I created
4. Example .env file entries with placeholder values
5. Which values are safe to expose in client-side code

Clarify the difference between client-safe and server-only Cloudinary credentials.
Phase 2: Core Upload Service
Prompt 2.1 - Basic Cloudinary Upload Service

Create a client-side service for uploading files directly to Cloudinary.

File: `src/services/cloudinaryService.js`

Include these functions:
- uploadFile(file, folder) - upload single file with progress tracking
- uploadMultipleFiles(files, folder) - batch upload with individual progress
- generateOptimizedUrl(publicId, transformations) - create optimized URLs
- validateFile(file) - client-side validation before upload

Requirements:
1. Use fetch API to POST directly to Cloudinary upload endpoint
2. Include upload progress callbacks
3. Return both secure_url and public_id from Cloudinary response
4. Handle network errors and Cloudinary API errors
5. Use the config from our cloudinary.js file

Do not integrate with components yet - just provide the service file.
Prompt 2.2 - Upload Progress Hook

Create a React hook for managing upload state and progress.

File: `src/hooks/useCloudinaryUpload.js`

The hook should provide:
- upload(file, options) - function to start upload
- progress - upload progress percentage (0-100)
- isUploading - boolean upload state
- uploadedData - Cloudinary response data when complete
- error - error message if upload fails
- reset() - function to reset upload state

Use the uploadFile function from our cloudinaryService.
Include proper cleanup to prevent memory leaks.
Phase 3: Component Integration
Prompt 3.1 - Reusable Upload Component

Create a reusable file upload component with drag-and-drop support.

File: `src/components/MediaUpload.jsx`

Features:
1. Drag-and-drop zone with visual feedback
2. Click to browse file selection
3. File preview before upload
4. Upload progress indicator
5. Success state with preview of uploaded media
6. Error handling with user-friendly messages

Props:
- onUploadComplete(cloudinaryData) - callback with upload results
- acceptedTypes - array of allowed MIME types
- maxSize - maximum file size in bytes
- folder - target folder in Cloudinary
- multiple - allow multiple file selection

Use our useCloudinaryUpload hook for upload functionality.
Prompt 3.2 - Optimized Image Display Component

Create a component for displaying Cloudinary images with automatic optimization.

File: `src/components/CloudinaryImage.jsx`

Features:
1. Automatic format optimization (WebP, AVIF when supported)
2. Responsive images with different sizes for different screen sizes
3. Lazy loading with intersection observer
4. Blur placeholder while loading
5. Error handling with fallback image
6. Optional transformations (crop, resize, filters)

Props:
- publicId - Cloudinary public ID
- alt - image alt text
- width, height - display dimensions
- transformations - optional transformation object
- lazy - enable/disable lazy loading

Use Cloudinary's URL transformation API for optimization.
Prompt 3.3 - Convert Existing Upload Component

I have an existing component that handles file uploads. Convert it to use Cloudinary.

Here's my current component: [paste your existing upload component]

Refactor this component to:
1. Replace the old upload logic with our MediaUpload component
2. Handle the onUploadComplete callback to save URLs
3. Maintain the same user interface and experience
4. Remove any old file handling code
5. Keep all existing validation and error handling

Only modify this single component file.
Phase 4: Firestore Integration
Prompt 4.1 - Media Metadata Service

Create a service to store Cloudinary media metadata in Firestore.

File: `src/services/mediaMetadataService.js`

Include functions:
- saveMediaMetadata(userId, cloudinaryData, customMetadata) - save after upload
- getMediaByUser(userId) - retrieve user's uploaded media
- updateMediaMetadata(mediaId, updates) - update existing metadata
- deleteMediaMetadata(mediaId) - remove from Firestore (not Cloudinary)
- searchMedia(userId, filters) - search with filters

Metadata structure should include:
- cloudinaryPublicId, cloudinaryUrl, uploadedAt, uploadedBy
- fileType, fileSize, dimensions, format
- custom tags and descriptions

Use the Firestore instance from our existing Firebase config.
Prompt 4.2 - Complete Upload and Save Flow

Create a service that combines Cloudinary upload with Firestore metadata storage.

File: `src/services/completeMediaService.js`

Main function: uploadAndSave(file, userId, metadata)

This function should:
1. Validate file before upload
2. Upload to Cloudinary using our cloudinaryService
3. Save metadata to Firestore using our mediaMetadataService
4. Return combined result (URLs + Firestore document ID)
5. Handle partial failures (if Firestore save fails after upload)
6. Provide progress updates throughout the process

Include comprehensive error handling and user feedback.
Prompt 4.3 - User Profile Image Integration

Update my user profile component to use Cloudinary for profile images.

Here's my current profile component: [paste your profile component]

Modify to:
1. Replace any existing image upload with our MediaUpload component
2. Upload profile images to users/{userId}/profile/ folder
3. Save the Cloudinary URL to the user's Firestore document
4. Display profile image using our CloudinaryImage component
5. Handle the case where user has no profile image (show default)

Only modify this profile component.
Phase 5: Advanced Features
Prompt 5.1 - Image Transformation Service

Create a service for generating optimized image URLs with Cloudinary transformations.

File: `src/services/imageTransformService.js`

Include functions:
- getResponsiveImageSet(publicId) - generate srcset for responsive images
- getThumbnail(publicId, size) - square thumbnails (50x50, 100x100, 200x200)
- getProfileAvatar(publicId) - circular crop for user avatars
- getOptimizedImage(publicId, maxWidth, quality) - size and quality optimization
- applyFilter(publicId, filterName) - artistic filters (sepia, grayscale, etc.)
- generateBlurPlaceholder(publicId) - low-quality placeholder for lazy loading

Each function should return properly formatted Cloudinary URLs.
Include TypeScript types or JSDoc comments for parameters.
Prompt 5.2 - Media Gallery Component

Create a media gallery component to display user's uploaded media.

File: `src/components/MediaGallery.jsx`

Features:
1. Grid layout with responsive columns (1-4 columns based on screen size)
2. Thumbnail view using Cloudinary transformations
3. Click to view full-size in lightbox/modal
4. Filter by media type (images, videos, documents)
5. Infinite scroll or pagination for large collections
6. Bulk selection with actions (delete metadata, add tags)

Data source: Fetch from Firestore using our mediaMetadataService
Image optimization: Use our imageTransformService for thumbnails
Prompt 5.3 - Video Upload and Player

Extend our upload system to handle video files with Cloudinary.

Create: `src/components/VideoUpload.jsx`

Features:
1. Video file selection with format validation
2. Upload progress with time remaining estimate
3. Video preview after upload using Cloudinary's video player
4. Automatic thumbnail generation
5. Transcoding status tracking (Cloudinary processes videos asynchronously)
6. Support for multiple video formats (MP4, MOV, AVI)

Integration:
- Use our existing upload infrastructure
- Save video metadata to Firestore
- Handle video-specific Cloudinary responses
Phase 6: Security and Validation
Prompt 6.1 - Client-Side File Validation

Create comprehensive file validation before uploading to Cloudinary.

File: `src/services/fileValidationService.js`

Validation checks:
- File type validation (MIME type and extension matching)
- File size limits (different for images/videos/documents)
- Image dimension validation (minimum and maximum)
- Basic malicious file detection (check file headers)
- User upload quota enforcement (daily/monthly limits)

Each validation should return detailed error messages for user feedback.
Integrate with Firebase Auth to get current user for quota checks.
Prompt 6.2 - Upload Rate Limiting

Implement client-side rate limiting to prevent abuse of Cloudinary uploads.

File: `src/services/rateLimitService.js`

Features:
- Track uploads per user per hour/day
- Implement exponential backoff for failed uploads
- Queue uploads when rate limit is reached
- Store rate limit data in localStorage
- Provide user feedback about rate limits

Integration with our upload services to automatically apply rate limiting.
Phase 7: Deletion Strategy (Important Limitation)
Prompt 7.1 - Deletion Limitation Explanation

Explain the limitation of file deletion in a client-side Cloudinary setup.

Clarify:
1. Why clients cannot securely delete files from Cloudinary
2. What happens to "orphaned" files when users delete content
3. Strategies to minimize orphaned files
4. Whether this limitation is acceptable for my use case
5. Alternative approaches (Cloud Functions, webhooks, manual cleanup)

Provide recommendations for managing this limitation in production.
Prompt 7.2 - Metadata Cleanup Service

Since we can't delete files from Cloudinary client-side, create a service to manage metadata cleanup.

File: `src/services/metadataCleanupService.js`

Functions:
- markMediaAsDeleted(mediaId) - soft delete in Firestore
- getOrphanedMedia(userId) - find media marked for deletion
- cleanupUserMedia(userId) - remove deleted media metadata
- scheduleCleanup(mediaId, deleteAfter) - mark for future cleanup

This allows the app to "delete" media from user perspective while keeping Cloudinary files for potential batch cleanup later.
Phase 8: Testing and Deployment
Prompt 8.1 - Upload Flow Testing

Create tests for the complete Cloudinary upload and save flow.

File: `tests/mediaUpload.test.js`

Test scenarios:
1. Successful file upload returns Cloudinary data
2. File validation rejects invalid files
3. Upload progress callbacks work correctly
4. Failed uploads handle errors gracefully
5. Metadata is saved to Firestore after successful upload
6. Rate limiting prevents excessive uploads

Use Jest and mock Cloudinary API responses for testing.
Set up test environment with test upload preset.
Prompt 8.2 - Production Configuration

Prepare Cloudinary integration for production deployment.

Verify:
1. Production upload presets are configured with proper security
2. Environment variables are set correctly for production
3. File size and type restrictions are appropriate
4. Upload quotas prevent abuse
5. Cloudinary account limits are sufficient for expected usage
6. Error monitoring is configured (Sentry, etc.)

Provide a pre-deployment checklist for Cloudinary integration.
Phase 9: Server Cleanup
Prompt 9.1 - Identify Remaining Backend Dependencies

Help me verify that my app no longer needs the Express server.

I'll provide my current app structure and remaining API calls.

Check for:
1. Any remaining calls to /api/ endpoints
2. Components still using server-side upload logic
3. Authentication flows that require backend
4. File operations that haven't been migrated to Cloudinary

Tell me what still needs to be converted before I can safely delete the server folder.
Prompt 9.2 - Final Server Removal

I've verified all functionality works with client-side Firebase and Cloudinary.

Help me safely remove the server folder:
1. Which npm packages I can uninstall (express, multer, etc.)
2. Which files and folders are server-only and can be deleted
3. How to update package.json scripts
4. Steps to verify the app still works after cleanup

Be conservative - tell me to keep anything you're unsure about.