You are an expert full‑stack engineer (Next.js or React/Vite, Firebase v9, Firestore, Vercel).

My ecommerce site has a checkout flow: Cart → Information → Payment → Confirmation.

On the Payment step, when the user clicks “Complete Order” with Cash on Delivery (COD) selected, I get a red toast that says:

“Error – No response body from server”

The button then becomes disabled for a moment and nothing else happens.
The order is not saved in Firestore and does not appear in the admin orders panel.

I want you to debug and fully fix this.

Project details:

Frontend: Next.js App Router or React with Vite (please detect from repo).
Styling: Tailwind CSS + Shadcn/UI.
Authentication: Firebase Auth v9+.
Database: Firestore.
Hosting: Vercel.
Repo URL: <REPO_URL>
Project root in Replit (if not “/”): <PROJECT_PATH>
Please proceed in these steps:

Project orientation
a. Confirm whether the app is using: – Next.js App Router, or
– Next.js pages router, or
– React + Vite with a separate backend.
b. Find and list the key files involved in checkout and orders: – The Payment step / checkout page that renders the “Complete Order” button.
– The function that runs when this button is clicked.
– Any API route or backend handler that is supposed to receive the order (for example an orders API endpoint).
– The admin orders list and order details views.
– The Firebase / Firestore configuration file(s).
c. Briefly tell me which specific files you will modify.

Understand the current “Complete Order” flow
a. In the Payment step component, inspect the click handler for “Complete Order”.
b. Describe in words, not code, exactly what it does:
– What URL it calls.
– Which HTTP method it uses.
– What data it sends (user ID, cart items, totals, shipping address, etc.).
– How it processes the response and under which condition it shows the message “No response body from server”.
c. Use browser devtools (Network tab) and logging to determine:
– Whether the request actually reaches the server.
– The status code that comes back.
– Whether any response body is present.
– Any console errors on the client side.

Inspect the backend handler for order creation
a. Find the API route or server function that should receive the order.
b. Explain how it currently:
– Reads the request body.
– Validates the data.
– Writes the order to Firestore (order document and line items, if any).
– Returns a response to the client.
c. Identify why the client ends up with “No response body from server”. Possibilities include:
– The frontend is calling a URL that does not match any route (for example orders vs order).
– The handler throws an error before sending a response.
– The handler sometimes returns a response without a body or with a body in a format the client does not expect.
– A runtime import error or environment issue causing the route to crash on Vercel.
d. Use server logs or Replit logs to confirm the actual error if the handler is crashing.

Fix the API contract and error handling
a. Adjust the order API route so that:
– It is reachable at a clear, documented URL that matches what the frontend calls.
– For every execution path (success, validation errors, server errors), it always returns a well‑formed JSON response body that includes at least:
* A boolean success flag.
* A human‑readable message.
* The new order ID in the success case.
b. Make sure there are no branches where the function finishes without returning any response at all.
c. Ensure any exceptions are caught and turned into a JSON error response rather than letting the framework return a blank or HTML error.
d. Verify that the Firestore operations in this route use a consistent structure for orders and their items, matching what the rest of the project expects.

Fix the frontend “Complete Order” handler to align with the backend
a. Update the handler so that it:
– Calls the correct URL using the correct HTTP method.
– Sends the required data from the checkout state (user ID, cart items, totals, shipping details, payment method).
– Parses the JSON response from the server.
– Distinguishes between:
* A genuine network failure (no HTTP response at all).
* A valid HTTP response with a success flag set to false (application error).
b. Change the error toast logic so that:
– “No response body from server” (or similar) is shown only in the rare case that there was truly no usable HTTP response or no parsable body.
– In ordinary application errors, the toast shows the specific message returned by the backend (for example, “Missing shipping address” or “Permission denied”).
c. Confirm that after these changes, clicking “Complete Order” with valid data results in a success response, the toast shows a success message, and any follow‑up navigation (like redirecting to a confirmation page) works as intended.

Verify Firestore writes and security rules
a. Run a test order and check Firestore directly to confirm that:
– A new order document is created in the intended collection.
– Any order items (line items) are created in the intended location (for example, as a subcollection or linked collection).
b. If Firestore rules are blocking these writes, identify the exact rule failure and update the rules so that authenticated users are allowed to create orders and associated items.
c. Keep access rules strict enough to prevent unauthorized writes, but permissive enough for this normal flow.

Connect the admin panel to the actual order data
a. Examine the admin orders list and order‑details views:
– Which collection and path are they currently reading from?
– How do they map Firestore documents to the UI?
b. Update the admin queries and mapping so that they read from the same place and with the same field names that the checkout flow writes to.
c. Confirm that:
– New orders placed from the checkout appear in the admin orders list.
– When an admin opens a specific order, its details match the Firestore data (customer info, payment method, shipping info, subtotal, shipping, total).
– Line items are shown correctly (product, quantity, price).

Admin access and permissions
a. Identify how the project currently determines who is an admin (for example using Firebase custom claims or a roles document).
b. Ensure that:
– Regular users can only see their own orders where appropriate.
– Admins can see all orders in the admin interface.
c. If necessary, refine Firestore security rules so that this is also enforced at the database level and explain what assumptions you made about admin configuration.

Final verification and summary
a. Run a full manual test flow and describe it:
– Sign in as a normal user.
– Add an item to the cart and go through Cart → Information → Payment.
– Click “Complete Order”.
– Observe the HTTP response, the user‑facing toast, and the resulting navigation.
b. Confirm that:
– There is no longer any “No response body from server” error in normal operation.
– A proper JSON response is always returned on both success and error cases.
– Orders and their items are correctly written to Firestore.
– The admin panel shows the new order and its details.
c. Provide me with a short, high‑level explanation (no code) covering:
– The root cause of the “No response body from server” issue.
– The key changes you made on the frontend, backend, and Firestore rules.
– Any manual actions I still need to take, such as setting environment variables, redeploying Firestore rules, or defining admin users.