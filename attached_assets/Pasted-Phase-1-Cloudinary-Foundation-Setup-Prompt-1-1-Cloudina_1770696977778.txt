Phase 1: Cloudinary Foundation Setup
Prompt 1.1 - Cloudinary Configuration File

I want to add Cloudinary to my client-side Firebase app for media storage.

Create a new file: `src/config/cloudinary.js`

This file should:
1. Export Cloudinary configuration for client-side uploads
2. Use environment variables for cloud name and upload preset
3. NOT include any secret keys or API secrets (client-side only)
4. Include the upload endpoint URL for direct uploads

Tell me which npm packages to install for client-side Cloudinary integration.
Do not modify any existing Firebase configuration files.
Prompt 1.2 - Upload Preset Configuration Guide

Explain how to create unsigned upload presets in Cloudinary Console for secure client-side uploads.

Provide step-by-step instructions for:
1. Creating an unsigned upload preset
2. Configuring allowed file types (images, videos, documents)
3. Setting file size limits (2MB for images, 10MB for videos)
4. Setting up folder organization (users/{user-id}/)
5. Enabling auto-optimization and format conversion
6. Security restrictions to prevent abuse

Include which settings are critical for security in a client-side setup.
Don't write code yet - just provide Cloudinary Console configuration steps.
Prompt 1.3 - Environment Variables Setup

Based on the Cloudinary config we're creating, tell me:
1. Which environment variables I need for client-side Cloudinary integration
2. How to get the cloud name from Cloudinary Console
3. How to get the upload preset name I created
4. Example .env file entries with placeholder values
5. Which values are safe to expose in client-side code

Clarify the difference between client-safe and server-only Cloudinary credentials.
Phase 2: Core Upload Service
Prompt 2.1 - Basic Cloudinary Upload Service

Create a client-side service for uploading files directly to Cloudinary.

File: `src/services/cloudinaryService.js`

Include these functions:
- uploadFile(file, folder) - upload single file with progress tracking
- uploadMultipleFiles(files, folder) - batch upload with individual progress
- generateOptimizedUrl(publicId, transformations) - create optimized URLs
- validateFile(file) - client-side validation before upload

Requirements:
1. Use fetch API to POST directly to Cloudinary upload endpoint
2. Include upload progress callbacks
3. Return both secure_url and public_id from Cloudinary response
4. Handle network errors and Cloudinary API errors
5. Use the config from our cloudinary.js file

Do not integrate with components yet - just provide the service file.
Prompt 2.2 - Upload Progress Hook

Create a React hook for managing upload state and progress.

File: `src/hooks/useCloudinaryUpload.js`

The hook should provide:
- upload(file, options) - function to start upload
- progress - upload progress percentage (0-100)
- isUploading - boolean upload state
- uploadedData - Cloudinary response data when complete
- error - error message if upload fails
- reset() - function to reset upload state

Use the uploadFile function from our cloudinaryService.
Include proper cleanup to prevent memory leaks.
Phase 3: Component Integration
Prompt 3.1 - Reusable Upload Component

Create a reusable file upload component with drag-and-drop support.

File: `src/components/MediaUpload.jsx`

Features:
1. Drag-and-drop zone with visual feedback
2. Click to browse file selection
3. File preview before upload
4. Upload progress indicator
5. Success state with preview of uploaded media
6. Error handling with user-friendly messages

Props:
- onUploadComplete(cloudinaryData) - callback with upload results
- acceptedTypes - array of allowed MIME types
- maxSize - maximum file size in bytes
- folder - target folder in Cloudinary
- multiple - allow multiple file selection

Use our useCloudinaryUpload hook for upload functionality.
Prompt 3.2 - Optimized Image Display Component

Create a component for displaying Cloudinary images with automatic optimization.

File: `src/components/CloudinaryImage.jsx`

Features:
1. Automatic format optimization (WebP, AVIF when supported)
2. Responsive images with different sizes for different screen sizes
3. Lazy loading with intersection observer
4. Blur placeholder while loading
5. Error handling with fallback image
6. Optional transformations (crop, resize, filters)

Props:
