üß© PART 1 ‚Äî Context & Requirements for Edit/Delete
You are an expert full‚Äëstack engineer and Firebase/Next.js specialist.

I already have a working product review system (create + list) using:

Frontend: Next.js App Router (or React with Vite)
Styling: Tailwind CSS + Shadcn/UI
Auth: Firebase Auth v9+ (modular)
Database: Firestore
Media: Cloudinary
Deployment: Vercel
Now I want you to add Edit and Delete capabilities for the comments/reviews.

1. Existing Assumptions
Assume:

Each review is stored in Firestore either as:
products/{productId}/reviews/{reviewId}
or
a top‚Äëlevel reviews/{reviewId} collection where each doc has productId.
Each review document includes at least:
userId
productId
rating
comment
images?
createdAt
Users are authenticated via Firebase Auth, and the current user can be accessed in React (e.g. useAuthState, custom hook, or context).
Only the owner of a review (same userId as auth.currentUser.uid) should be able to edit or delete that review.
2. High‚ÄëLevel Goals
I need you to implement:

UI controls:

An ‚ÄúEdit‚Äù and ‚ÄúDelete‚Äù option per review, visible only to the review‚Äôs owner.
Use Shadcn/UI patterns where possible (e.g. dropdown menu, dialog, alert dialog).
Edit behavior:

When the user clicks ‚ÄúEdit‚Äù, open a modal or an inline form:
Pre‚Äëfilled with the existing rating, comment, and optionally images.
Allow the user to update rating and comment at minimum.
On submit, update the Firestore document (updateDoc).
Show success/error toasts.
Delete behavior:

When clicking ‚ÄúDelete‚Äù, show a confirmation dialog.
On confirm, delete the Firestore document (deleteDoc).
Optionally remove images from Cloudinary if there‚Äôs already a mechanism for that.
Show success/error toasts.
Realtime UI refresh:

After edit or delete, the Customer Reviews list should update automatically if we‚Äôre using onSnapshot; otherwise, re‚Äëfetch or update local state.
Please first locate the components & hooks involved, then proceed.

üß© PART 2 ‚Äî Firestore Logic, Security Rules, and UI Wiring
1. Implement Firestore Edit Logic
Find where reviews are mapped into UI (e.g. reviews.map(review => <ReviewCard ... />)).

For each review item component (e.g. ReviewCard, CustomerReviewItem):

Ensure we have access to:

review.id
review.userId
review.productId
Import Firestore functions:

Copyimport { doc, updateDoc, deleteDoc } from "firebase/firestore";
import { db } from "@/lib/firebase";
Implement an handleEditReview flow:

Determine the correct doc reference based on the existing data model, e.g.:

Copyconst reviewRef = doc(
  db,
  "products",
  productId,
  "reviews",
  reviewId
);
or

Copyconst reviewRef = doc(db, "reviews", reviewId);
Use updateDoc(reviewRef, { rating, comment, updatedAt: serverTimestamp() }).

Implement an handleDeleteReview flow:

Get the same reviewRef.
Call await deleteDoc(reviewRef).
Add robust error handling for both:

Copytry {
  setIsUpdating(true);
  await updateDoc(...);
  toast.success("Review updated");
} catch (error) {
  console.error("Error updating review:", error);
  toast.error("Failed to update review.");
} finally {
  setIsUpdating(false);
}
And similarly for delete.

Ensure that the success toast only fires when the Firestore operation succeeds.

2. Update Firestore Security Rules
Open the Firestore security rules file (e.g. firestore.rules).

Modify the rules for the reviews collection or subcollection to allow:

Any user to read reviews.
Only the owner (request.auth.uid == resource.data.userId) to update or delete.
Use a pattern like:

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // If using subcollection under products:
    match /products/{productId}/reviews/{reviewId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid;

      allow update, delete: if request.auth != null
        && request.auth.uid == resource.data.userId;
    }

    // OR, if using top-level /reviews collection:
    match /reviews/{reviewId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid;

      allow update, delete: if request.auth != null
        && request.auth.uid == resource.data.userId;
    }
  }
}
Make sure the rules match the actual path used in the app (subcollection vs top-level).

Explain any rule changes you make and what security they enforce.

3. UI Components for Edit/Delete
In the Review item component:

Get the current user‚Äôs ID (e.g. const user = useAuth(); or similar).

Conditionally render the Edit/Delete controls:

Copyconst canModify = user?.uid === review.userId;
Only show the menu/buttons if canModify is true.

Use Shadcn/UI where possible:

For options: DropdownMenu or Popover with ‚ÄúEdit‚Äù and ‚ÄúDelete‚Äù.
For edit form: Dialog or inline form with Form, Input, Textarea, Button.
For delete confirmation: AlertDialog (‚ÄúAre you sure?‚Äù with Confirm/Cancel).
State management for editing:

isEditOpen (boolean for dialog).
editRating, editComment, etc. prefilled from review.
On open, copy current review data into local state.
On submit, call handleEditReview with updated values.
For delete:

isDeleteOpen for the confirmation dialog.
On confirm, call handleDeleteReview(review.id, review.productId).
Ensure loading states:

Disable buttons while isUpdating or isDeleting.
Optionally show a spinner.
üß© PART 3 ‚Äî Optional: Image Updates, Cleanup, and Final Summary
1. Optional: Editing Images
If my reviews support images and it‚Äôs not too complex, add:

In the edit dialog:
Show existing image thumbnails.
Option to remove an image from the list.
Option to add new images (same Cloudinary upload flow as create).
On save:
Build the final images array (kept + new).
Include it in updateDoc(reviewRef, { images: finalImages }).
If this becomes too large of a change, focus on rating & comment editing first and describe what would be needed to extend to images later.

2. Code Cleanup & Types
Define or update a shared Review / ProductReview TypeScript interface to include id and userId.
Make sure all edit/delete handlers use these types and correct Firestore paths.
Remove any unused or duplicate editing/deleting code if present.
3. Final Deliverables and Explanation for Me
When you‚Äôre done:

List all files modified, e.g.:

components/CustomerReviews.tsx
components/ReviewCard.tsx
hooks/useProductReviews.ts
lib/firebase.ts (if needed)
firestore.rules
Show key before/after code snippets for:

The review card (without vs with edit/delete).
The new handleEditReview and handleDeleteReview logic.
The updated Firestore security rules.
Explain clearly:

How a user can now edit their review (UI steps).
How delete works and what gets removed.
How the Customer Reviews list reacts in real time or via re‚Äëfetch.
Confirm that:

Only the review‚Äôs owner sees and can use Edit/Delete.
On edit:
Firestore doc updates.
UI reflects the change.
On delete:
Firestore doc is removed.
The review disappears from the list without a full page refresh.
No new console errors are introduced.
This is the complete specification for adding edit and delete functionality to the comment/review system.